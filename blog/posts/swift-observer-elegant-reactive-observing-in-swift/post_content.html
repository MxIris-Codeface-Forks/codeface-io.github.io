<img src="images/swift.jpeg"/></p>

<p><i>Care about the code? Jump over to <a href="https://github.com/flowtoolz/SwiftObserver">SwiftObserver on Github</a>.</i></p>

<p>Recently I’ve been discussing app architecture a lot with colleagues. As ever so often, our main question was: How do we propagate information from the bottom of the hierarchy to the top?</p>

<p>Delegates came up and where quickly dismissed. Notifications came up and where quickly dismissed. Closures came up and were embraced. Functional stuff is all the craze. For good reasons.</p>

<p>We looked at different Reactive/Redux frameworks: Reactive Swift, Reactive Kit, ReSwift, RxSwift.</p>

<p>To be honest, I was a bit overwhelmed by all the new terms around old ideas and old terms for new applications: observable, reducer, aspect, signal, signal producer, variable, stream, cancelable, disposable, dispose bag, event emitter, source, sink…</p>

<p>However, I got obsessed with callback mechanisms in general and in Swift in particular.</p>

<p>As a method of exploring and learning, I wrote three fundamental primitives for reactive Swift programming, which are solid, simple, sufficient and sweet for my own taste.</p>

<p>This compact library also compensates for what I didn’t like about common implementations. I guess I aimed at usability, readability, simplicity, safety and flexibility.</p>

<p><a href="https://github.com/flowtoolz/SwiftObserver">Checkout SwiftObserver on Github</a>. You can read the text there as the continuation of this article.</p>
